- add a special instruction called "Halt" (or similar) to simulate the end-of-list effect
- return could just be end-of-list
- closures are immediately called apparently? No, nevermind, they aren't
- value.VarV not used
- use integers instead of var=string to identify rec defs

Instructions:
Cons/Push/Swap/App/Return: constants
QuoteB/I: prefix * value
Cur: prefix * code pointer
Branch: prefix * code pointer * code pointer
AddDefs: array of pointers (with NULL as final value?)
	OR: pointer to an array of code pointer that would be saved to the virtmem,
	then the deflist contains a list of (arrays of) pointers to arrays of code pointers?
	with lengths saved to skip over quickly
RmDefs: just remove the latest link of the chain, so we don't need to save a value:
	thus it can be a constant

Terms can be:
- pairs (Term + Term)
- booleans,
- ints,
- closure (Code + Term)
- Null (empty term)

execute one instruction:
- input:
	pointer to next instruction
	term
	stack (linked list?)
	defstack

- output:
	next instruction
	new term
	new stack
	new defstack
